title=<h1 align="center">A1-Injection</h1>
description=<h2 align="center">A general description of the problem</h2>Injection flaws, such as SQL, OS, and LDAP injection occur when untrusted data is sent to an interpreter as part of a command or query. The attacker\u2019s hostile data can trick the interpreter into executing unintended commands or accessing data without proper authorization.
impact=<h2 align="center">Outline typical impact of attacks exploiting that weakness</h2><p><b>Am I Vulnerable To 'Injection'?</b></p><p align="justify">The best way to find out if an application is vulnerable to injection is to verify that all use of interpreters clearly separates untrusted data from the command or query. For SQL calls, this means using bind variables in all prepared statements and stored procedures, and avoiding dynamic queries.<br>Checking the code is a fast and accurate way to see if the application uses interpreters safely. Code analysis tools can help a security analyst find the use of interpreters and trace the data flow through the application. Penetration testers can validate these issues by crafting exploits that confirm the vulnerability.<br>utomated dynamic scanning which exercises the application may provide insight into whether some exploitable injection flaws exist. Scanners cannot always reach interpreters and have difficulty detecting whether an attack was successful. Poor error handling makes injection flaws easier to discover</p>
scenario=<h2 align="center">Example Attack Scenarios</h2><p><b>Scenario #1:</b></p><p>The application uses untrusted data in the construction of the following vulnerable SQL call:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String query = "SELECT * FROM accounts WHERE custID='" + request.getParameter("id") + "'";</p><p><b>Scenario #2:</b>,</p><p>Similarly, an application\u2019s blind trust in frameworks may result in queries that are still vulnerable, (e.g., Hibernate Query Language (HQL)):</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query HQLQuery = session.createQuery(\u201cFROM accounts WHERE custID='\u201c + request.getParameter("id") + "'");</p><p>In both cases, the attacker modifies the \u2018id\u2019 parameter value in her browser to send: ' or '1'='1. For example:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://example.com/app/accountView?id=' or '1'='1</p><p>This changes the meaning of both queries to return all the records from the accounts table. More dangerous attacks could modify data or even invoke stored procedures.</p>
avoid=<h2 align="center">Outline how the weakness can be avoided</h2><p><b>How Do I Prevent 'Injection'?</b></p>Preventing injection requires keeping untrusted data separate from commands and queries. <ol><li>The preferred option is to use a safe API which avoids the use of the interpreter entirely or provides a parameterized interface. Be careful with APIs, such as stored procedures, that are parameterized, but can still introduce injection under the hood.</li><li>If a parameterized API is not available, you should carefully escape special characters using the specific escape syntax for that interpreter. OWASP\u2019s ESAPI provides many of these escaping routines.</li><li>Positive or \u201cwhite list\u201d input validation is also recommended, but is not a complete defense as many applications require special characters in their input. If special characters are required, only approaches 1. and 2. above will make their use safe. OWASP\u2019s ESAPI has an extensible library of white list input validation routines.</li></ol>
external_resources=<h2 align="center">Links to external resources for further information</h2><ul><li><a href="http://cwe.mitre.org/data/definitions/77.html">CWE Entry 77 on Command Injection</a></li><li><a href="http://cwe.mitre.org/data/definitions/89.html">CWE Entry 89 on SQL Injection</a></li><li><a href="http://cwe.mitre.org/data/definitions/564.html">CWE Entry 564 on Hibernate Injection</a></li></ul> 